"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var types = require("../lib/types");
var Type = types.Type;
var builtin = types.builtInTypes;
var isNumber = builtin.number;

// An example of constructing a new type with arbitrary constraints from
// an existing type.
exports.geq = function (than) {
    return new Type(function (value) {
        return isNumber.check(value) && value >= than;
    }, isNumber + " >= " + than);
};

// Default value-returning functions that may optionally be passed as a
// third argument to Def.prototype.field.
exports.defaults = {
    // Functions were used because (among other reasons) that's the most
    // elegant way to allow for the emptyArray one always to give a new
    // array instance.
    "null": function _null() {
        return null;
    },
    "emptyArray": function emptyArray() {
        return [];
    },
    "false": function _false() {
        return false;
    },
    "true": function _true() {
        return true;
    },
    "undefined": function undefined() {}
};

var naiveIsPrimitive = Type.or(builtin.string, builtin.number, builtin.boolean, builtin.null, builtin.undefined);

exports.isPrimitive = new Type(function (value) {
    if (value === null) return true;
    var type = typeof value === "undefined" ? "undefined" : _typeof(value);
    return !(type === "object" || type === "function");
}, naiveIsPrimitive.toString());